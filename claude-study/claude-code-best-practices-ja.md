# Claude Code のベストプラクティス

Claude Code はエージェント型のコーディング環境です。質問に答えて待機するチャットボットとは異なり、Claude Code はファイルを読み取り、コマンドを実行し、変更を加え、あなたが見守る間、リダイレクトする間、あるいは完全に離席している間も自律的に問題に取り組むことができます。

これによって作業方法が変わります。自分でコードを書いて Claude にレビューを頼む代わりに、何が欲しいかを説明すれば Claude がどう構築するかを考え出します。Claude が探索し、計画し、実装します。

しかし、この自律性には学習曲線が伴います。Claude は理解すべき一定の制約の中で動作します。このガイドでは、Anthropic の社内チームや様々なコードベース、言語、環境で Claude Code を使用するエンジニアの間で効果的であることが証明されたパターンを紹介します。

エージェントループが内部でどのように機能するかについては、「Claude Code の仕組み」を参照してください。

## ほとんどのベストプラクティスは1つの制約に基づいている

**Claude のコンテキストウィンドウはすぐにいっぱいになり、いっぱいになるとパフォーマンスが低下する。**

Claude のコンテキストウィンドウは、会話全体、Claude が読んだすべてのファイル、すべてのコマンド出力を保持します。しかし、これはすぐにいっぱいになります。1回のデバッグセッションやコードベースの探索で、数万トークンを生成し消費することがあります。

これが重要なのは、コンテキストがいっぱいになるにつれて LLM のパフォーマンスが低下するからです。コンテキストウィンドウがいっぱいになると、Claude は以前の指示を「忘れ」始めたり、より多くのミスを犯したりする可能性があります。

**コンテキストウィンドウは管理すべき最も重要なリソースです。**

トークン使用量を減らす詳細な戦略については、「トークン使用量の削減」を参照してください。

---

## Claude に作業を検証する方法を与える

テスト、スクリーンショット、または期待される出力を含めて、Claude が自己チェックできるようにしましょう。

**これは最もレバレッジの高いことです。**

Claude は自分の作業を検証できる場合、テストを実行したり、スクリーンショットを比較したり、出力を検証したりできる場合に、劇的に優れたパフォーマンスを発揮します。明確な成功基準がなければ、正しく見えるが実際には機能しないものを生成する可能性があります。あなたが唯一のフィードバックループになり、すべてのミスにあなたの注意が必要になります。

| 戦略 | 変更前 | 変更後 |
|------|--------|--------|
| 検証基準を提供する | 「メールアドレスを検証する関数を実装して」 | 「validateEmail 関数を書いて。テストケースの例：user@example.com は true、invalid は false、user@.com は false。実装後にテストを実行して」 |
| UI の変更を視覚的に検証する | 「ダッシュボードをもっと良くして」 | 「[スクリーンショットを貼り付け] このデザインを実装して。結果のスクリーンショットを撮って元と比較して。違いをリストアップして修正して」 |
| 症状ではなく根本原因に対処する | 「ビルドが失敗してる」 | 「このエラーでビルドが失敗してる：[エラーを貼り付け]。修正してビルドが成功することを確認して。エラーを抑制するのではなく、根本原因に対処して」 |

UI の変更は Claude in Chrome 拡張機能を使用して検証できます。ブラウザを開き、UI をテストし、コードが動作するまで反復します。

検証はテストスイート、リンター、または出力をチェックする Bash コマンドでも可能です。検証を堅牢にすることに投資しましょう。

---

## まず探索し、次に計画し、それからコーディングする

リサーチと計画を実装から分離して、間違った問題を解決することを避けましょう。

Claude にすぐにコーディングに飛び込ませると、間違った問題を解決するコードが生成される可能性があります。Plan Mode を使用して探索と実行を分離しましょう。

推奨されるワークフローには4つのフェーズがあります：

### 1. 探索
Plan Mode に入ります。Claude は変更を加えずにファイルを読み、質問に答えます。

```
claude (Plan Mode)
/src/auth を読んで、セッションとログインをどう扱っているか理解して。
また、シークレットの環境変数をどう管理しているかも見て。
```

### 2. 計画
Claude に詳細な実装計画を作成するよう依頼します。

```
claude (Plan Mode)
Google OAuth を追加したい。どのファイルを変更する必要がある？
セッションフローは？計画を作成して。
```

Ctrl+G を押すと、Claude が進む前にテキストエディタで計画を直接編集できます。

### 3. 実装
Normal Mode に戻り、Claude に計画に対して検証しながらコーディングさせます。

```
claude (Normal Mode)
計画から OAuth フローを実装して。コールバックハンドラーのテストを書いて、
テストスイートを実行して失敗があれば修正して。
```

### 4. コミット
Claude に説明的なメッセージでコミットし、PR を作成するよう依頼します。

```
claude (Normal Mode)
説明的なメッセージでコミットして PR を開いて
```

---

Plan Mode は便利ですが、オーバーヘッドも追加します。スコープが明確で修正が小さいタスク（タイポの修正、ログ行の追加、変数名の変更など）では、Claude に直接依頼しましょう。

計画が最も有用なのは、アプローチが不確かな場合、変更が複数のファイルを修正する場合、または変更されるコードに不慣れな場合です。差分を一文で説明できるなら、計画はスキップしましょう。

---

## プロンプトで具体的なコンテキストを提供する

指示が正確であるほど、修正が少なくて済みます。

Claude は意図を推測できますが、心は読めません。特定のファイルを参照し、制約を言及し、サンプルパターンを指し示しましょう。

| 戦略 | 変更前 | 変更後 |
|------|--------|--------|
| タスクのスコープを定める。どのファイル、どのシナリオ、テストの好みを指定する | 「foo.py のテストを追加して」 | 「foo.py のテストを書いて、ユーザーがログアウトしているエッジケースをカバーして。モックは避けて」 |
| ソースを指し示す。Claude が質問に答えられるソースに誘導する | 「なぜ ExecutionFactory はこんな奇妙な API なの？」 | 「ExecutionFactory の git 履歴を調べて、その API がどうやって今の形になったかまとめて」 |
| 既存のパターンを参照する。コードベースのパターンを Claude に示す | 「カレンダーウィジェットを追加して」 | 「ホームページの既存のウィジェットがどう実装されているか見て、パターンを理解して。HotDogWidget.php が良い例。そのパターンに従って、ユーザーが月を選択して前後にページネーションして年を選べる新しいカレンダーウィジェットを実装して。コードベースで既に使われているライブラリ以外は使わずにゼロから構築して」 |
| 症状を説明する。症状、問題の場所、「修正された」とはどういう状態かを提供する | 「ログインのバグを修正して」 | 「ユーザーからセッションタイムアウト後にログインが失敗するという報告がある。src/auth/ の認証フロー、特にトークンリフレッシュを確認して。問題を再現する失敗するテストを書いて、それから修正して」 |

曖昧なプロンプトは、探索していて軌道修正する余裕がある場合に有用です。「このファイルで何を改善する？」のようなプロンプトは、聞こうと思わなかったことを表面化させることができます。

---

## リッチなコンテンツを提供する

@ を使ってファイルを参照したり、スクリーンショット/画像を貼り付けたり、データを直接パイプしたりしましょう。

Claude にリッチなデータを提供する方法はいくつかあります：

- **@ でファイルを参照**する：コードがどこにあるか説明する代わりに。Claude は応答する前にファイルを読みます。
- **画像を直接貼り付け**る：コピー＆ペーストまたはドラッグ＆ドロップでプロンプトに画像を入れます。
- **ドキュメントと API リファレンスの URL を渡す**：/permissions を使って頻繁に使用するドメインを許可リストに追加します。
- **データをパイプで送る**：`cat error.log | claude` を実行してファイル内容を直接送信します。
- **Claude に必要なものを取得させる**：Bash コマンド、MCP ツール、またはファイル読み取りを使って、Claude 自身にコンテキストを取得させます。

---

## 環境を設定する

いくつかのセットアップ手順で、すべてのセッションで Claude Code がはるかに効果的になります。

拡張機能の機能と各機能をいつ使用するかの完全な概要については、「Claude Code の拡張」を参照してください。

### 効果的な CLAUDE.md を書く

`/init` を実行して、現在のプロジェクト構造に基づいたスターター CLAUDE.md ファイルを生成し、時間をかけて改良しましょう。

CLAUDE.md は、Claude がすべての会話の開始時に読む特別なファイルです。Bash コマンド、コードスタイル、ワークフロールールを含めましょう。これにより、Claude にコードだけからは推測できない永続的なコンテキストが与えられます。

`/init` コマンドはコードベースを分析してビルドシステム、テストフレームワーク、コードパターンを検出し、改良するための堅固な基盤を提供します。

CLAUDE.md ファイルには必須の形式はありませんが、短く人間が読めるようにしましょう。例：

```markdown
# コードスタイル
- ES モジュール（import/export）構文を使用、CommonJS（require）ではない
- 可能な場合はインポートを分割構文にする（例：import { foo } from 'bar'）

# ワークフロー
- 一連のコード変更を終えたら必ず型チェックを行う
- パフォーマンスのため、テストスイート全体ではなく単一テストの実行を優先する
```

CLAUDE.md は毎セッション読み込まれるので、広く適用されるものだけを含めましょう。特定の場合にのみ関連するドメイン知識やワークフローについては、代わりにスキルを使用しましょう。Claude はすべての会話を膨らませずにオンデマンドで読み込みます。

**簡潔に保つこと。** 各行について「これを削除したら Claude がミスを犯すか？」と自問しましょう。そうでなければ、削除します。肥大化した CLAUDE.md ファイルは Claude に実際の指示を無視させます！

| ✅ 含めるべき | ❌ 除外すべき |
|--------------|--------------|
| Claude が推測できない Bash コマンド | Claude がコードを読めばわかること |
| デフォルトと異なるコードスタイルルール | Claude が既に知っている標準的な言語規約 |
| テスト指示と優先テストランナー | 詳細な API ドキュメント（代わりにリンク） |
| リポジトリのエチケット（ブランチ命名、PR 規約） | 頻繁に変更される情報 |
| プロジェクト固有のアーキテクチャ決定 | 長い説明やチュートリアル |
| 開発環境の癖（必要な環境変数） | コードベースのファイルごとの説明 |
| よくある落とし穴や非自明な動作 | 「クリーンなコードを書く」のような自明な実践 |

ルールがあるにもかかわらず Claude が望まないことを続ける場合、ファイルが長すぎてルールが埋もれている可能性があります。Claude が CLAUDE.md で回答されている質問をしてくる場合、表現が曖昧かもしれません。

CLAUDE.md をコードのように扱いましょう：問題が発生したらレビューし、定期的に剪定し、Claude の行動が実際に変わるかどうかを観察して変更をテストしましょう。

強調（例：「IMPORTANT」や「YOU MUST」）を追加して、順守を向上させることができます。

CLAUDE.md を git にチェックインして、チームが貢献できるようにしましょう。ファイルは時間とともに価値が複利で増加します。

CLAUDE.md ファイルは `@path/to/import` 構文を使って追加ファイルをインポートできます：

```markdown
プロジェクト概要は @README.md を、利用可能な npm コマンドは @package.json を参照。

# 追加の指示
- Git ワークフロー：@docs/git-instructions.md
- 個人的なオーバーライド：@~/.claude/my-project-instructions.md
```

CLAUDE.md ファイルはいくつかの場所に配置できます：

- **ホームフォルダ** (`~/.claude/CLAUDE.md`)：すべての Claude セッションに適用
- **プロジェクトルート** (`./CLAUDE.md`)：git にチェックインしてチームと共有、または CLAUDE.local.md と名付けて .gitignore に追加
- **親ディレクトリ**：monorepo で root/CLAUDE.md と root/foo/CLAUDE.md の両方が自動的に取り込まれる場合に便利
- **子ディレクトリ**：それらのディレクトリ内のファイルで作業する際に、Claude がオンデマンドで子の CLAUDE.md ファイルを取り込む

### 権限を設定する

`/permissions` を使って安全なコマンドを許可リストに追加するか、`/sandbox` で OS レベルの分離を行いましょう。これにより中断が減りつつ、制御を維持できます。

デフォルトでは、Claude Code はシステムを変更する可能性のあるアクション（ファイル書き込み、Bash コマンド、MCP ツールなど）に対して許可を要求します。これは安全ですが面倒です。10回目の承認後は、本当にレビューしているわけではなく、ただクリックしているだけです。

これらの中断を減らす方法は2つあります：

- **権限許可リスト**：安全とわかっている特定のツール（npm run lint や git commit など）を許可する
- **サンドボックス化**：ファイルシステムとネットワークアクセスを制限する OS レベルの分離を有効にし、Claude が定義された境界内でより自由に作業できるようにする

または、lint エラーの修正やボイラープレートの生成のような限定されたワークフローに対して `--dangerously-skip-permissions` を使用してすべての権限チェックをバイパスします。

⚠️ **Claude に任意のコマンドを実行させると、データ損失、システム破損、またはプロンプトインジェクションによるデータ漏洩が発生する可能性があります。`--dangerously-skip-permissions` はインターネットアクセスのないサンドボックス内でのみ使用してください。**

権限の設定とサンドボックスの有効化についてはドキュメントを参照してください。

### CLI ツールを使用する

外部サービスとやり取りする際は、gh、aws、gcloud、sentry-cli などの CLI ツールを使用するよう Claude Code に伝えましょう。

CLI ツールは外部サービスとやり取りする最もコンテキスト効率の良い方法です。GitHub を使用している場合、gh CLI をインストールしましょう。Claude は issue の作成、プルリクエストのオープン、コメントの読み取りに使用方法を知っています。

gh がなくても Claude は GitHub API を使用できますが、認証されていないリクエストはレート制限に達することがよくあります。

Claude はまだ知らない CLI ツールの学習にも効果的です。「'foo-cli-tool --help' を使って foo ツールについて学び、それを使って A、B、C を解決して」のようなプロンプトを試してみましょう。

### MCP サーバーに接続する

`claude mcp add` を実行して Notion、Figma、またはデータベースなどの外部ツールに接続しましょう。

MCP サーバーを使えば、issue トラッカーから機能を実装したり、データベースをクエリしたり、監視データを分析したり、Figma からデザインを統合したり、ワークフローを自動化したりするよう Claude に依頼できます。

### フックを設定する

例外なく毎回発生する必要があるアクションにはフックを使用しましょう。

フックは Claude のワークフローの特定のポイントで自動的にスクリプトを実行します。アドバイス的な CLAUDE.md の指示とは異なり、フックは決定論的でアクションが発生することを保証します。

Claude にフックを書かせることができます。「すべてのファイル編集後に eslint を実行するフックを書いて」や「migrations フォルダへの書き込みをブロックするフックを書いて」などのプロンプトを試してみましょう。

インタラクティブな設定には `/hooks` を実行するか、.claude/settings.json を直接編集します。

### スキルを作成する

.claude/skills/ に SKILL.md ファイルを作成して、Claude にドメイン知識と再利用可能なワークフローを与えましょう。

スキルは、プロジェクト、チーム、またはドメインに固有の情報で Claude の知識を拡張します。Claude は関連する場合に自動的に適用するか、`/skill-name` で直接呼び出すことができます。

.claude/skills/ にディレクトリと SKILL.md を追加してスキルを作成します：

```markdown
---
name: api-conventions
description: サービスの REST API 設計規約
---

# API 規約

- URL パスには kebab-case を使用
- JSON プロパティには camelCase を使用
- リストエンドポイントには常にページネーションを含める
- API のバージョンは URL パスに含める（/v1/、/v2/）
```

スキルは直接呼び出す繰り返し可能なワークフローも定義できます：

```markdown
---
name: fix-issue
description: GitHub issue を修正する
disable-model-invocation: true
---

GitHub issue を分析して修正する：$ARGUMENTS。

1. `gh issue view` を使用して issue の詳細を取得
2. issue に記述された問題を理解
3. 関連ファイルをコードベースで検索
4. issue を修正するために必要な変更を実装
5. 修正を検証するテストを書いて実行
6. コードがリンティングと型チェックをパスすることを確認
7. 説明的なコミットメッセージを作成
8. プッシュして PR を作成
```

`/fix-issue 1234` を実行して呼び出します。手動でトリガーしたい副作用のあるワークフローには `disable-model-invocation: true` を使用しましょう。

### カスタムサブエージェントを作成する

分離されたタスクのために Claude が委譲できる専門のアシスタントを .claude/agents/ に定義しましょう。

サブエージェントは、独自のコンテキストと許可されたツールのセットで実行されます。多くのファイルを読むタスクや、メインの会話を乱雑にせずに専門的なフォーカスが必要なタスクに便利です。

```markdown
---
name: security-reviewer
description: セキュリティ脆弱性のコードレビュー
tools: Read, Grep, Glob, Bash
model: opus
---

あなたはシニアセキュリティエンジニアです。以下についてコードをレビューしてください：

- インジェクション脆弱性（SQL、XSS、コマンドインジェクション）
- 認証と認可の欠陥
- コード内のシークレットや認証情報
- 安全でないデータ処理

具体的な行の参照と修正案を提供してください。
```

Claude に明示的にサブエージェントを使用するよう伝えましょう：「サブエージェントを使ってこのコードのセキュリティ問題をレビューして」。

### プラグインをインストールする

`/plugin` を実行してマーケットプレイスを閲覧しましょう。プラグインは設定なしでスキル、ツール、統合を追加します。

プラグインは、コミュニティと Anthropic からのスキル、フック、サブエージェント、MCP サーバーを1つのインストール可能なユニットにバンドルします。

型付き言語で作業する場合は、コードインテリジェンスプラグインをインストールして、Claude に正確なシンボルナビゲーションと編集後の自動エラー検出を提供しましょう。

スキル、サブエージェント、フック、MCP の選択についてのガイダンスは、「Claude Code の拡張」を参照してください。

---

## 効果的にコミュニケーションする

Claude Code とのコミュニケーション方法は、結果の品質に大きく影響します。

### コードベースについて質問する

シニアエンジニアに聞くような質問を Claude にしましょう。

新しいコードベースにオンボーディングする際、学習と探索のために Claude Code を使用しましょう。他のエンジニアに聞くのと同じ種類の質問を Claude にできます：

- ログ記録はどう動作する？
- 新しい API エンドポイントはどう作る？
- foo.rs の 134 行目の `async move { ... }` は何をしている？
- CustomerOnboardingFlowImpl はどんなエッジケースを処理する？
- なぜこのコードは 333 行目で bar() の代わりに foo() を呼び出している？

この方法で Claude Code を使用することは効果的なオンボーディングワークフローで、立ち上がり時間を改善し、他のエンジニアの負担を減らします。特別なプロンプトは不要です：直接質問しましょう。

### Claude にインタビューさせる

大きな機能については、まず Claude にインタビューさせましょう。

最小限のプロンプトから始めて、AskUserQuestion ツールを使ってインタビューするよう Claude に依頼しましょう。Claude は技術的な実装、UI/UX、エッジケース、トレードオフなど、まだ考慮していなかったかもしれないことについて質問します。

```
[簡単な説明] を構築したい。AskUserQuestion ツールを使って詳細にインタビューして。
技術的な実装、UI/UX、エッジケース、懸念事項、トレードオフについて聞いて。
明らかな質問はせず、考慮していなかったかもしれない難しい部分を掘り下げて。
すべてをカバーするまでインタビューを続けて、それから完全な仕様を SPEC.md に書いて。
```

仕様が完成したら、新しいセッションを開始して実行しましょう。新しいセッションには実装のみに焦点を当てたクリーンなコンテキストがあり、参照する文書化された仕様があります。

---

## セッションを管理する

会話は永続的で可逆的です。これを活用しましょう！

### 早めに、頻繁に軌道修正する

Claude が逸れていることに気づいたらすぐに修正しましょう。

最良の結果は密なフィードバックループから生まれます。Claude が時々最初の試みで問題を完璧に解決することもありますが、素早く修正することで一般的により良いソリューションがより速く生まれます。

- **Esc**：Esc キーで Claude をアクション中に停止。コンテキストは保存されるのでリダイレクトできます。
- **Esc + Esc または /rewind**：Esc を2回押すか `/rewind` を実行して巻き戻しメニューを開き、以前の会話とコードの状態を復元。
- **「それを元に戻して」**：Claude に変更を取り消させます。
- **`/clear`**：無関係なタスク間でコンテキストをリセット。無関係なコンテキストを持つ長いセッションはパフォーマンスを低下させる可能性があります。

同じセッションで同じ問題について2回以上 Claude を修正した場合、コンテキストは失敗したアプローチで汚染されています。`/clear` を実行して、学んだことを取り入れたより具体的なプロンプトで新たに始めましょう。

より良いプロンプトを持つクリーンなセッションは、蓄積された修正を持つ長いセッションをほぼ常に上回ります。

### コンテキストを積極的に管理する

無関係なタスク間で `/clear` を実行してコンテキストをリセットしましょう。

Claude Code はコンテキスト制限に近づくと自動的に会話履歴をコンパクト化し、重要なコードと決定を保持しながらスペースを解放します。

長いセッション中、Claude のコンテキストウィンドウは無関係な会話、ファイル内容、コマンドでいっぱいになる可能性があります。これによりパフォーマンスが低下し、Claude の気が散ることがあります。

- タスク間で頻繁に `/clear` を使用して、コンテキストウィンドウを完全にリセット
- 自動コンパクションがトリガーされると、Claude はコードパターン、ファイル状態、重要な決定など、最も重要なものを要約
- より細かい制御には `/compact <指示>` を実行。例：`/compact API の変更に焦点を当てて`
- CLAUDE.md で「コンパクト時には、変更されたファイルの完全なリストとテストコマンドを常に保持する」のような指示を追加して、重要なコンテキストが要約後も残るようにカスタマイズ

### 調査にサブエージェントを使用する

「サブエージェントを使って X を調査して」で調査を委譲しましょう。サブエージェントは別のコンテキストで探索し、メインの会話を実装のためにクリーンに保ちます。

コンテキストが根本的な制約であるため、サブエージェントは利用可能な最も強力なツールの1つです。Claude がコードベースを調査すると、多くのファイルを読み取り、それらすべてがコンテキストを消費します。サブエージェントは別のコンテキストウィンドウで実行し、要約を報告します：

```
サブエージェントを使って、認証システムがトークンリフレッシュをどう処理するか、
再利用すべき既存の OAuth ユーティリティがあるかを調査して。
```

サブエージェントはコードベースを探索し、関連ファイルを読み、発見を報告します。すべてメインの会話を乱雑にすることなく。

Claude が何かを実装した後の検証にもサブエージェントを使用できます：

```
サブエージェントを使ってこのコードのエッジケースをレビューして
```

### チェックポイントで巻き戻す

Claude が行うすべてのアクションはチェックポイントを作成します。会話、コード、または両方を任意の以前のチェックポイントに復元できます。

Claude は変更前に自動的にチェックポイントを作成します。Escape をダブルタップするか `/rewind` を実行してチェックポイントメニューを開きます。会話のみを復元（コード変更を保持）、コードのみを復元（会話を保持）、または両方を復元できます。

すべての動きを慎重に計画する代わりに、Claude にリスクのあることを試させることができます。うまくいかなければ、巻き戻して別のアプローチを試しましょう。

チェックポイントはセッション間で永続化されるので、ターミナルを閉じても後で巻き戻せます。

チェックポイントは Claude による変更のみを追跡し、外部プロセスは追跡しません。これは git の代わりではありません。

### 会話を再開する

`claude --continue` を実行して中断したところから再開するか、`--resume` で最近のセッションから選択しましょう。

Claude Code は会話をローカルに保存します。タスクが複数のセッションにまたがる場合（機能を開始し、中断され、翌日に戻る）、コンテキストを再説明する必要はありません：

```bash
claude --continue  # 最新の会話を再開
claude --resume    # 最近の会話から選択
```

`/rename` を使用してセッションに説明的な名前（「oauth-migration」、「debugging-memory-leak」）を付けると、後で見つけやすくなります。

セッションをブランチのように扱いましょう。異なるワークストリームには、別々の永続的なコンテキストを持たせることができます。

---

## 自動化とスケール

1つの Claude で効果的になったら、並列セッション、ヘッドレスモード、ファンアウトパターンで出力を倍増させましょう。

ここまでのすべては、1人の人間、1つの Claude、1つの会話を前提としています。しかし Claude Code は水平方向にスケールします。このセクションのテクニックは、より多くのことを達成する方法を示します。

### ヘッドレスモードを実行する

CI、プリコミットフック、またはスクリプトで `claude -p "プロンプト"` を使用しましょう。ストリーミング JSON 出力には `--output-format stream-json` を追加します。

`claude -p "プロンプト"` で、インタラクティブセッションなしでヘッドレスで Claude を実行できます。ヘッドレスモードは、CI パイプライン、プリコミットフック、または任意の自動化ワークフローに Claude を統合する方法です。

出力形式（プレーンテキスト、JSON、ストリーミング JSON）により、結果をプログラムで解析できます。

```bash
# ワンオフクエリ
claude -p "このプロジェクトが何をするか説明して"

# スクリプト用の構造化出力
claude -p "すべての API エンドポイントをリストして" --output-format json

# リアルタイム処理用のストリーミング
claude -p "このログファイルを分析して" --output-format stream-json
```

### 複数の Claude セッションを実行する

開発を高速化したり、分離された実験を実行したり、複雑なワークフローを開始したりするために、複数の Claude セッションを並列で実行しましょう。

並列セッションを実行する主な方法は2つあります：

- **Claude Desktop**：複数のローカルセッションを視覚的に管理。各セッションは独自の分離されたワークツリーを持ちます。
- **Claude Code on the web**：Anthropic のセキュアなクラウドインフラストラクチャ上で分離された VM で実行。

作業を並列化する以外に、複数のセッションは品質重視のワークフローを可能にします。Claude は自分が書いたばかりのコードにバイアスがかからないため、新しいコンテキストでコードレビューが改善されます。

例えば、Writer/Reviewer パターンを使用：

| セッション A（Writer） | セッション B（Reviewer） |
|----------------------|------------------------|
| API エンドポイント用のレートリミッターを実装して | @src/middleware/rateLimiter.ts のレートリミッター実装をレビューして。エッジケース、競合状態、既存のミドルウェアパターンとの一貫性を確認して。 |
| レビューフィードバックはこちら：[セッション B の出力]。これらの問題に対処して。 | |

テストでも同様のことができます：1つの Claude にテストを書かせ、別の Claude にそれをパスするコードを書かせます。

### ファイル間でファンアウトする

タスクをループして各タスクに対して `claude -p` を呼び出しましょう。バッチ操作のスコープを制限するには `--allowedTools` を使用します。

大規模な移行や分析では、多くの並列 Claude 呼び出しに作業を分散できます：

#### 1. タスクリストを生成
移行が必要なすべてのファイルをリストアップするよう Claude に依頼（例：移行が必要な 2,000 個の Python ファイルすべてをリスト）

#### 2. リストをループするスクリプトを書く

```bash
for file in $(cat files.txt); do
  claude -p "$file を React から Vue に移行して。OK または FAIL を返して。" \
    --allowedTools "Edit,Bash(git commit *)"
done
```

#### 3. 数ファイルでテストし、その後スケールで実行
最初の 2〜3 ファイルでうまくいかなかったことに基づいてプロンプトを改良し、その後フルセットで実行。

`--allowedTools` フラグは Claude ができることを制限します。これは無人で実行する場合に重要です。

既存のデータ/処理パイプラインに Claude を統合することもできます：

```bash
claude -p "<プロンプト>" --output-format json | your_command
```

開発中のデバッグには `--verbose` を使用し、本番では無効にしましょう。

### セーフ自律モード

すべての権限チェックをバイパスして Claude が中断なく作業できるようにするには `claude --dangerously-skip-permissions` を使用しましょう。これは lint エラーの修正やボイラープレートコードの生成などのワークフローに適しています。

⚠️ Claude に任意のコマンドを実行させることはリスクがあり、データ損失、システム破損、またはデータ漏洩（例：プロンプトインジェクション攻撃による）を引き起こす可能性があります。これらのリスクを最小限に抑えるため、`--dangerously-skip-permissions` はインターネットアクセスのないコンテナ内で使用してください。

サンドボックス化（`/sandbox`）を有効にすると、より良いセキュリティで同様の自律性が得られます。サンドボックスはすべてのチェックをバイパスするのではなく、事前に境界を定義します。

---

## よくある失敗パターンを避ける

これらはよくある間違いです。早めに認識することで時間を節約できます：

### キッチンシンクセッション
1つのタスクから始めて、無関係なことを Claude に尋ね、最初のタスクに戻る。コンテキストが無関係な情報でいっぱい。
**修正**：無関係なタスク間で `/clear`。

### 何度も修正する
Claude が何か間違える、修正する、まだ間違っている、また修正する。コンテキストは失敗したアプローチで汚染されている。
**修正**：2回失敗した修正の後、`/clear` して学んだことを取り入れたより良い初期プロンプトを書く。

### 過剰に指定された CLAUDE.md
CLAUDE.md が長すぎると、Claude は半分を無視する。重要なルールがノイズに埋もれる。
**修正**：無慈悲に剪定する。指示なしでも Claude が既に正しく行っている場合は、削除するかフックに変換する。

### 信頼してから検証のギャップ
Claude がエッジケースを処理しない、もっともらしく見える実装を生成する。
**修正**：常に検証を提供する（テスト、スクリプト、スクリーンショット）。検証できなければ、出荷しない。

### 無限の探索
スコープを指定せずに Claude に何かを「調査」するよう依頼。Claude が何百ものファイルを読み、コンテキストがいっぱいになる。
**修正**：調査のスコープを狭くするか、サブエージェントを使用して探索がメインのコンテキストを消費しないようにする。

---

## 直感を養う

このガイドのパターンは固定されたものではありません。一般的にうまく機能する出発点ですが、すべての状況に最適とは限りません。

時にはコンテキストを蓄積させるべきです。1つの複雑な問題に深く取り組んでいて、履歴が価値あるからです。時には計画をスキップして Claude に任せるべきです。タスクが探索的だからです。時には曖昧なプロンプトがまさに正しいです。制約する前に Claude が問題をどう解釈するか見たいからです。

うまくいくことに注意を払いましょう。Claude が素晴らしい出力を生成したとき、何をしたか気づきましょう：プロンプトの構造、提供したコンテキスト、使用していたモード。Claude が苦戦したときは、なぜか問いましょう。コンテキストがノイズだらけだった？プロンプトが曖昧すぎた？タスクが1回のパスには大きすぎた？

時間とともに、ガイドでは捉えられない直感が養われます。いつ具体的にして、いつオープンエンドにするか。いつ計画して、いつ探索するか。いつコンテキストをクリアして、いつ蓄積させるか。わかるようになります。

---

## 関連リソース

- **Claude Code の仕組み**：エージェントループ、ツール、コンテキスト管理を理解する
- **Claude Code の拡張**：スキル、フック、MCP、サブエージェント、プラグインを選択する
- **一般的なワークフロー**：デバッグ、テスト、PR などのステップバイステップレシピ
- **CLAUDE.md**：プロジェクトの規約と永続的なコンテキストを保存する
